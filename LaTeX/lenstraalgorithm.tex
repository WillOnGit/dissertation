% Don't forget to talk about how you spent ages writing a ======= implementation of the alg!
\begin{definition}
	The modular exponentiation algorithm allows highly efficient calculation of expressions of the form $a^k$ mod $n$, even when the numbers involved are very large.
	To improve on the naive method of repeatedly multiplying by $a$ and reducing mod n, observe that, for $k=500$,
$$500=2^2+2^4+2^5+2^6+2^7+2^8$$
and therefore $a^k$ may be written as
$$a^{500} = a^{2^{2}} \times a^{2^{4}} \times a^{2^{5}} \times a^{2^{6}} \times a^{2^{7}} \times a^{2^{8}}$$
these terms are much easier to calculate by successively squaring and reducing mod $n$.
Let $A_0 = a$ and calculate
\begin{align*}
	A_1\equiv A_0\cdot &A_0 \equiv a^2 \mod n\\
	A_2\equiv A_1\cdot &A_1 \equiv a^4 \mod n\\
	A_3\equiv A_2\cdot &A_2 \equiv a^8 \mod n\\
	&\vdots\\
	A_l\equiv A_{l-1}\cdot &A_{l-1} \equiv a^{2^{l}} \mod n
\end{align*}
and then calculate $a^{500} = A_2 \times A_4 \times A_5 \times A_6 \times A_7 \times A_8 \mod n$.
\end{definition}
As the numbers involved grow larger, the time savings over the trivial method become enormous, as this is an $O(\log_2(k))$ algorithm, and it is this algorithm which we shall use in our arithmetic.
\begin{definition}
	Lenstra's algorithm goes roughly as follows to factor an integer $N$:
	\begin{itemize}
		\item Choose random integers $b$, $x$ and $y \mod N$
		\item Let $P = (x,y)$ and $c:=y^2-x^3-bx$ such that $P$ is a point on the curve $C: Y^2 = X^3 +bX + c \mod N$
		\item Compute $kP$ for large $k$ ($k=10!$, for example)
		\item If the computation of $kP$ is successful, increment $b$ and restart
		\item Continue until one of the additions fails
	\end{itemize}
\end{definition}
Whilst this may seem strange, considering everything we have discussed so far, it makes sense.
What we are doing is taking an integer $N$ that we know is composite and attempting to use it as the modulus in a finite field $\fp[N]$.
But because it is composite, we know that $\fp[N]$ will not be a proper field, as some elements will not have multiplicative inverses.
If we attempt to calculate the inverses of these elements with the euclidean algorithm, we will be unable to, as they will not be coprime with $N$.
But this very calculation will give us a non-trivial divisor of $N$, so it will not matter that we cannot calculate the inverses.
